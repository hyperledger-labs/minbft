// Copyright (c) 2018 NEC Laboratories Europe GmbH.
//
// Authors: Sergey Fedorov <sergey.fedorov@neclab.eu>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef USIG_H__
#define USIG_H__

#include <stddef.h>
#include <stdint.h>

#include <sgx_urts.h>
#include <sgx_tcrypto.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * usig_ui - structure representing a unique identifier
 * @epoch:     unique value for each new USIG instance
 * @counter:   counter value
 * @signature: USIG signature over the digest followed by the epoch
 *             and counter values in little-endian byte order
 */
typedef struct {
        uint64_t epoch;
        uint64_t counter;
        sgx_ec256_signature_t signature;
} usig_ui;

/**
 * usig_init() - Create and initialize an instance of USIG enclave
 * @enclave_file:     path to the enclave image file
 * @enclave_id:       pointer to store enclave ID to
 * @sealed_data:      pointer to sealed key or NULL
 * @selaed_data_size: length of the buffer @sealed_data points to
 *
 * Sealed key can be obtained by usig_seal_key() from another USIG
 * instance. If a valid data is supplied as @sealed_data then the
 * enclave will use this key to produce UI certificates, otherwise a
 * new key pair will be generated. In any case, each enclave instance
 * will initialize epoch to a random value.
 *
 * The normal sequence would be to create a USIG instance for the
 * first time on the machine by passing NULL as @sealed_data. A new
 * key pair will be generated by the enclave in that case. Then the
 * key pair can be sealed using usig_seal_key(). The sealed key can be
 * stored permanently and reused on subsequent invocations of
 * usig_init().
 *
 * Return: SGX_SUCCESS if no error; SGX error status, otherwise
 */
sgx_status_t usig_init(const char *enalave_file, sgx_enclave_id_t *enclave_id,
                       void *sealed_data, size_t sealed_data_size);

/**
 * usig_destroy() - Destroy a USIG enclave instance
 * @enclave_id: enclave ID returned by successful usig_init()
 *
 * Return: SGX_SUCCESS if no error; SGX error status, otherwise
 */
sgx_status_t usig_destroy(const sgx_enclave_id_t enclave_id);

/**
 * usig_create_ui() - Create a unique identifier (UI) for the message
 *                    digest
 * @enclave_id: enclave ID of the USIG instance returned by usig_init()
 * @digest:     message digest to create UI for
 * @ui:         pointer to usig_ui structure to store the UI to
 *
 * Return: SGX_SUCCESS if no error; SGX error status, otherwise
 */
sgx_status_t usig_create_ui(sgx_enclave_id_t enclave_id,
                            sgx_sha256_hash_t digest,
                            usig_ui *ui);

/**
 * usig_get_epoch() - Get epoch value of the USIG instance
 * @enclave_id: enclave ID of the USIG instance returned by
 *              usig_init()
 * @epoch:      pointer to store the epoch value to
 *
 * Epoch is a unique value for each new USIG instance. It is randomly
 * generated by the enclave during initialization.
 *
 * Return: SGX_SUCCESS if no error; SGX error status, otherwise
 */
sgx_status_t usig_get_epoch(sgx_enclave_id_t enclave_id,
                            uint64_t *epoch);

/**
 * usig_get_pub_key() - Get public key of the USIG instance
 * @enclave_id: enclave ID of the USIG instance returned by
 *              usig_init()
 * @pub_key:    pointer to store the public key to
 *
 * Return: SGX_SUCCESS if no error; SGX error status, otherwise
 */
sgx_status_t usig_get_pub_key(sgx_enclave_id_t enclave_id,
                              sgx_ec256_public_t *pub_key);

/**
 * usig_seal_key() - Get sealed key of the USIG instance
 * @enclave_id:       enclave ID of the USIG instance returned by
 *                    usig_init()
 * @sealed_data:      pointer to store the address to the sealed data
 *                    to. It is a responsibility of the caller to free
 *                    the memory buffer allocated by successful
 *                    invocation of this function
 * @sealed_data_size: pointer to store sealed data size to
 *
 * The retrieved sealed key can be supplied to usig_init(). The sealed
 * key is only valid on the same hardware platform, i.e. it cannot be
 * transferred to and reused on another physical machine.
 *
 * Return: SGX_SUCCESS if no error; SGX error status, otherwise
 */
sgx_status_t usig_seal_key(sgx_enclave_id_t enclave_id,
                           void **sealed_data,
                           size_t *sealed_data_size);

#ifdef __cplusplus
}
#endif

#endif // USIG_H__
