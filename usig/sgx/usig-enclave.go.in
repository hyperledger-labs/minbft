// Copyright (c) 2018 NEC Laboratories Europe GmbH.
//
// Authors: Sergey Fedorov <sergey.fedorov@neclab.eu>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sgx

// #cgo pkg-config: $SGX_URTS_PACKAGE
// #cgo CFLAGS: -I${SRCDIR}/shim
// #cgo LDFLAGS: -L${SRCDIR}/shim -lusig_shim
//
// #include <stdlib.h>
// #include "usig.h"
import "C"

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/sha256"
	"encoding/asn1"
	"fmt"
	"math/big"
	"sync"
	"unsafe"

	"github.com/nec-blockchain/minbft/usig"
)

// Digest represents the data type of the message digest used to
// create unique identifiers
type Digest [sha256.Size]byte

// USIGEnclave represents a USIG enclave instance.
type USIGEnclave struct {
	// USIG enclave is supposed to be single-threaded. This lock
	// is used to synchronize ECall invocations and avoid
	// SGX_ERROR_OUT_OF_TCS error.
	ecallLock sync.Mutex
	enclaveID C.sgx_enclave_id_t
	epoch     uint64
}

// NewUSIGEnclave creates a new instance of USIG enclave. Note that
// the created instance has to be disposed with Destroy() method, e.g.
// using defer. A sealed key, previously retrieved by SealedKey(), can
// be supplied to initialize the enclave with that key pair. If nil is
// passed instead then a new key pair will be generated by the
// enclave.
func NewUSIGEnclave(enclaveFile string, sealedKey []byte) (*USIGEnclave, error) {
	enclave := new(USIGEnclave)

	sealedDataSize := C.size_t(len(sealedKey))
	var sealedData unsafe.Pointer
	if sealedKey != nil && len(sealedKey) != 0 {
		// vet linter reports an error, but it's been recently fixed.
		// So disable linting until gometalinter picks up this update
		sealedData = C.CBytes(sealedKey) // nolint: vet
		defer C.free(sealedData)
	}

	sgxErr := C.usig_init(
		C.CString(enclaveFile), &enclave.enclaveID,
		sealedData, sealedDataSize,
	)
	if err := sgxError(sgxErr); err != nil {
		return nil, err
	}

	sgxSuccessOrPanic(C.usig_get_epoch(enclave.enclaveID, (*C.uint64_t)(&enclave.epoch)))

	return enclave, nil
}

// Destroy destroys previously created USIG enclave instance. Must be
// called only once per each enclave instance
func (enclave *USIGEnclave) Destroy() {
	// USIGEnclave is supposed to be exposed only after it has
	// been created and initialized successfully. Enclave destroy
	// can only fail if the enclave ID is not valid. That would
	// mean double-destroy here. This is deemed a programmer
	// error, similar to double-closing a channel, thus panic().
	enclave.ecallLock.Lock()
	sgxSuccessOrPanic(C.usig_destroy(enclave.enclaveID))
	enclave.ecallLock.Unlock()
}

// CreateUI creates a unique identifier assigned to the specified
// message digest.
func (enclave *USIGEnclave) CreateUI(digest Digest) (*usig.UI, error) {
	ui := new(C.usig_ui)

	enclave.ecallLock.Lock()
	sgxErr := C.usig_create_ui(enclave.enclaveID, (*C.uint8_t)(&digest[0]), ui)
	enclave.ecallLock.Unlock()
	if err := sgxError(sgxErr); err != nil {
		return nil, err
	}

	return &usig.UI{
		Epoch:   uint64(ui.epoch),
		Counter: uint64(ui.counter),
		Cert:    sgxEC256SigToASN1(&ui.signature),
	}, nil
}

// Epoch retrieves the unique epoch value generated by this USIG
// enclave instance.
func (enclave *USIGEnclave) Epoch() uint64 {
	return enclave.epoch
}

// PublicKey retrieves the public part of the key used by USIG enclave
// instance to sign unique identifiers it produces
func (enclave *USIGEnclave) PublicKey() crypto.PublicKey {
	sgxPubKey := new(C.sgx_ec256_public_t)

	enclave.ecallLock.Lock()
	sgxErr := C.usig_get_pub_key(enclave.enclaveID, sgxPubKey)
	enclave.ecallLock.Unlock()
	sgxSuccessOrPanic(sgxErr)

	return sgxEC256PubKeyToGo(sgxPubKey)
}

// SealedKey retrieves the sealed key used by the USIG enclave. The
// retrieved key can be supplied to subsequent calls to
// NewUSIGEnclave() on the same physical machine.
func (enclave *USIGEnclave) SealedKey() []byte {
	var sealedData unsafe.Pointer
	var sealedDataSize C.size_t

	enclave.ecallLock.Lock()
	sgxErr := C.usig_seal_key(enclave.enclaveID, &sealedData, &sealedDataSize)
	enclave.ecallLock.Unlock()
	sgxSuccessOrPanic(sgxErr)

	bytes := C.GoBytes(sealedData, C.int(sealedDataSize))
	C.free(sealedData)

	return bytes
}

func sgxError(sgxErr C.sgx_status_t) error {
	if sgxErr != C.SGX_SUCCESS {
		return fmt.Errorf("SGX error: %x", sgxErr)
	}

	return nil
}

func sgxSuccessOrPanic(sgxErr C.sgx_status_t) {
	if err := sgxError(sgxErr); err != nil {
		panic(err)
	}
}

func sgxEC256SigToASN1(sgxSig *C.sgx_ec256_signature_t) []byte {
	sgxR, sgxS := sgxSig.x[:], sgxSig.y[:] // nolint: gotype
	r := sgxUint32SliceToBigInt(sgxR)
	s := sgxUint32SliceToBigInt(sgxS)

	ret, err := asn1.Marshal(struct{ R, S *big.Int }{r, s})
	if err != nil {
		panic(err)
	}

	return ret
}

func sgxEC256PubKeyToGo(sgxPubKey *C.sgx_ec256_public_t) crypto.PublicKey {
	sgxX, sgxY := sgxPubKey.gx[:], sgxPubKey.gy[:] // nolint: gotype

	return &ecdsa.PublicKey{
		Curve: elliptic.P256(),
		X:     sgxUint8SliceToBigInt(sgxX),
		Y:     sgxUint8SliceToBigInt(sgxY),
	}
}

func sgxUint32SliceToBigInt(sgxArr []C.uint32_t) *big.Int {
	bytes := make([]byte, 0, len(sgxArr)*4)

	// Convert SGX representation encoded as a series of 32-bit
	// integers in little endian order to a big endian byte slice
	for i := len(sgxArr); i > 0; i-- {
		w := sgxArr[i-1]
		bytes = append(bytes,
			byte(w>>(3*8)),
			byte(w>>(2*8)),
			byte(w>>(1*8)),
			byte(w>>(0*8)))
	}

	return new(big.Int).SetBytes(bytes)
}

func sgxUint8SliceToBigInt(sgxArr []C.uint8_t) *big.Int {
	bytes := make([]byte, 0, len(sgxArr))

	// Convert SGX representation encoded as a series of bytes in
	// little endian order to big endian byte slice
	for i := len(sgxArr); i > 0; i-- {
		b := sgxArr[i-1]
		bytes = append(bytes, byte(b))
	}

	return new(big.Int).SetBytes(bytes)
}
