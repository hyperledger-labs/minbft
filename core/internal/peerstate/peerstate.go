// Copyright (c) 2018 NEC Laboratories Europe GmbH.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package peerstate provides means to interact with a representation
// of the state maintained by the replica for each peer replica.
package peerstate

import (
	"fmt"
	"sync"

	"github.com/nec-blockchain/minbft/usig"
)

// Provider returns an instance of state representation associated
// with a peer replica given its ID. It is safe to invoke
// concurrently.
type Provider func(replicaID uint32) State

// NewProvider creates an instance of Provider
func NewProvider() Provider {
	var (
		lock sync.Mutex
		// Replica ID -> replica state
		peerStates = make(map[uint32]State)
	)

	return func(replicaID uint32) State {
		lock.Lock()
		defer lock.Unlock()

		state := peerStates[replicaID]
		if state == nil {
			state = New()
			peerStates[replicaID] = state
		}

		return state
	}
}

// State represents the state maintained by the replica for each peer
// replica. All methods are safe to invoke concurrently.
//
// AcceptUI accepts a valid USIG unique identifier ui. A UI cannot be
// accepted until all previous UIs generated by that USIG instance
// have been accepted and committed. If the UI cannot be accepted
// immediately, it will block until the UI can be accepted. The return
// value new indicates if the UI has not been accepted before.
//
// CommitUI records the last accepted USIG unique identifier ui as
// committed so that the next UI can be accepted. Each UI can be
// committed one time only.
type State interface {
	AcceptUI(ui *usig.UI) (new bool)
	CommitUI(ui *usig.UI) error
}

// New creates a new instance of peer replica state representation.
func New() State {
	state := &peerState{}
	state.accepted = sync.NewCond(state)
	state.committed = sync.NewCond(state)
	return state
}

type peerState struct {
	sync.Mutex
	lastAcceptedCV  uint64
	lastCommittedCV uint64
	accepted        *sync.Cond
	committed       *sync.Cond
}

func (s *peerState) AcceptUI(ui *usig.UI) (new bool) {
	s.Lock()
	defer s.Unlock()

	for ui.Counter-1 > s.lastAcceptedCV {
		s.accepted.Wait()
	}
	for ui.Counter-1 > s.lastCommittedCV {
		s.committed.Wait()
	}

	if ui.Counter <= s.lastAcceptedCV {
		return false
	}

	s.lastAcceptedCV++
	s.accepted.Broadcast()

	return true
}

func (s *peerState) CommitUI(ui *usig.UI) error {
	s.Lock()
	defer s.Unlock()

	if ui.Counter != s.lastAcceptedCV {
		return fmt.Errorf("UI is not the last accepted")
	} else if ui.Counter <= s.lastCommittedCV {
		return fmt.Errorf("UI already committed")
	}

	s.lastCommittedCV = ui.Counter
	s.committed.Broadcast()

	return nil
}
